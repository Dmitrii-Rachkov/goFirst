package principles

import "fmt"

// Пример 1

/*
O) Open–closed principle / Принцип открытости-закрытости

Программные объекты должны быть открыты для расширения, но закрыты для модификации.
Речь о том, что нельзя переопределять методы или классы, просто добавляя дополнительные функции по мере необходимости.

Хороший способ решения этой проблемы – использование наследования. В JavaScript эта проблема решается с помощью композиции.

Простое правило: если вы изменяете сущность, чтобы сделать ее расширяемой, вы впервые нарушили этот принцип.
*/

// Допустим, у меня есть задача построить платежную систему, которая сможет обрабатывать платежи по кредитным картам.
// Она также должна быть достаточно гибкой, чтобы принимать различные типы платежных методов в будущем.

type PaymentMethod interface {
	Pay()
}

type Payment struct{}

func (p Payment) Process(pm PaymentMethod) {
	pm.Pay()
}

type CreditCard struct {
	amount float64
}

func (cc CreditCard) Pay() {
	fmt.Printf("Paid %.2f using CreditCard", cc.amount)
}

func main() {
	p := Payment{}
	cc := CreditCard{12.23}
	p.Process(cc)
}

/*
Согласно OCP, моя Payment структура открыта для расширения и закрыта для изменения. Поскольку я использую
PaymentMethod интерфейс, мне не нужно редактировать Payment поведение при добавлении новых способов оплаты.
Добавление чего-то вроде PayPal будет выглядеть так:
*/

type PayPal struct {
	amount float64
}

func (pp PayPal) Pay() {
	fmt.Printf("Paid %.2f using PayPal", pp.amount)
}

// then in main()
// pp := PayPal{22.33}
// p.Process(pp)

// Пример 2

/*
У нас есть тип A, с полем year и методом Greet. У нас есть второй тип, B который встраивает, A таким образом,
вызывающие видят B методы , наложенные на A, поскольку A встроен, как поле, в B, и B может предоставлять свой
собственный Greet метод, скрывая метод A.

Но встраивание не только для методов, оно также обеспечивает доступ к полям встраиваемого типа. Как видите, поскольку
тип A и B определены в одном пакете, B можно получить доступ A к закрытому year полю, как если бы оно было объявлено
внутри типа B.

Таким образом, встраивание — это мощный инструмент, позволяющий открывать типы Go для расширения.
*/

type A struct {
	year int
}

func (a A) Greet() { fmt.Println("Hello GolangUK", a.year) }

type B struct {
	A
}

func (b B) Greet() { fmt.Println("Welcome to GolangUK", b.year) }

func main2() {
	var a A
	a.year = 2016
	var b B
	b.year = 2016
	a.Greet() // Hello GolangUK 2016
	b.Greet() // Welcome to GolangUK 2016
}

// Пример 3

/*
В этом примере у нас есть Cat тип, который может подсчитывать количество своих ног с помощью своего Legs метода.
Мы встраиваем этот Cat тип в новый тип, an OctoCat, и объявляем, что Octocatу s пять ног.
Однако, хотя OctoCat определяет свой собственный Legs метод, который возвращает 5, при PrintLegs вызове метода он возвращает 4.

Это происходит потому, PrintLegs что определено в Cat типе. Он принимает Cat в качестве получателя и поэтому отправляет Cat методу Legs.
Cat не имеет сведений о типе, в который он был внедрен, поэтому его набор методов не может быть изменен путем внедрения.

Таким образом, можно сказать, что типы Go, хотя и открыты для расширения, закрыты для модификации.

По правде говоря, методы в Go — это не более чем синтаксический сахар вокруг функции с заранее объявленным формальным параметром — ее получателем.
*/

type Cat struct {
	Name string
}

func (c Cat) Legs() int { return 4 }

func (c Cat) PrintLegs() {
	fmt.Printf("У меня %d ног\n", c.Legs())
}

type OctoCat struct {
	Cat
}

func (o OctoCat) Legs() int { return 5 }

func main3() {
	var octo OctoCat
	fmt.Println(octo.Legs()) // 5
	octo.PrintLegs()         // У меня 4 ноги
}
