package principles

// Пример 1

/*
SOLID означает: Единая ответственность, Открыто-закрыто, Замена Лискова, Разделение интерфейса и Инверсия зависимостей.
В совокупности эти принципы составляют основу для создания удобного в сопровождении и масштабируемого программного
обеспечения и считаются лучшими практиками разработки программного обеспечения.
*/

/*
S) Single-responsibility principle /Принцип единственной ответственности

Его важность невозможно переоценить. Каждый объект, класс и метод должны отвечать только за что-то одно.
Если ваш объект/класс/метод делает слишком много, вы получите спагетти-код.

Это помогает поддерживать чистоту и удобство кода, поскольку изменения в структуре нужно вносить только в одном месте.
*/

// Допустим, у меня есть структура Employee, которая отслеживает имя, зарплату и адрес сотрудника:

type Employees struct {
	Name    string
	Salary  float64
	Address string
}

// Согласно SRP, каждая структура должна иметь только одну обязанность, поэтому в этом случае было бы лучше разделить
// обязанности структуры Employee на две отдельные структуры: EmployeeInfo и EmployeeAddress.

type EmployeesInfo struct {
	Name   string
	Salary float64
}

type EmployeesAddress struct {
	Address string
}

// Теперь у нас могут быть отдельные функции, которые обрабатывают различные обязанности каждой структуры:

func (e EmployeesInfo) GetName() string {
	return e.Name
}

func (e EmployeesInfo) GetSalary() float64 {
	return e.Salary
}

func (e EmployeesAddress) GetAddress() string {
	return e.Address
}

/*
Следуя SRP, я сделал код более удобным для поддержки и более понятным, поскольку теперь каждая структура имеет
четкую и конкретную ответственность.
Если мне нужно внести изменения в расчет зарплаты или обработку адресов, я точно знаю, где искать,
без необходимости продираться через кучу не связанного кода.
*/

// Пример 2

// Допустим у нас есть структура, в которой приватные поля (это ещё один принцип)

type Message struct {
	to   string
	from string
	text string
}

// Т.к. нет доступа к приватным полям структуры за пределами пакета, делаем getters и setters
// Функции укладываются в принцип SRP

func (m *Message) GetTo() string {
	return m.to
}

func (m *Message) GetFrom() string {
	return m.from
}

func (m *Message) GetText() string {
	return m.text
}

// А функция Send уже не укладывается, потому что выполняет уже другую обязанность

func (m *Message) Send() {
	// some code
}
