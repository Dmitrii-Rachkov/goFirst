package main

import "fmt"

/*
Параллельное программирование. Горутины

# Горутины

Горутины (goroutines) представляют параллельные операции, которые могут выполняться независимо от функции,
в которой они запущены. Главная особенность горутин состоит в том, что они могут выполняться параллельно.
То есть на многоядерных архитектурах есть возможность выполнять отдельные горутины на отдельных ядрах
процессора, тем самым горутины будут выполняться паралелльно, и программа завершится быстрее.

Каждая горутина, как правило, представляет вызов функции, и последовательно выполняет все свои инструкции.
Когда мы запускаем программу на Go, мы уже работаем как минимум с одной горутиной, которая представлена
функцией main. Эта функция последовательно выполняет все инструкции, которые определены внутри нее.

Для определения горутин применяется оператор go, который ставится перед вызовом функции:
go вызов_функции

Например, определим несколько горутин, вычисляющих факториал числа:
*/
func fac(n int) {
	if n < 1 {
		fmt.Println("Invalid input number")
		return
	}
	result := 1
	for i := 1; i <= n; i++ {
		result *= i
	}
	fmt.Println(n, "-", result)
}

func goroutine() {
	fmt.Println("Функция горутин")
	for i := 1; i < 7; i++ {
		go fac(i)
	}
	fmt.Println("The End")
}

/*
В цикле последовательно запускаются шесть горутин с помощью вызова go fac(i).
То есть фактически это обычный вызов функции с оператором go.
Однако вместо шести факториалов на консоли при вызове программы мы можем увидеть только строку "The End"
"Можем увидеть" означает, что поведение программы в данном случае недетерминировано.
Например, вывод может быть и таким:
2 - 2
1 - 1
4 - 24
The End
5 - 120

Почему так происходит? После вызова go fac(i) функция goroutine() запускает горутину,
которая начинает выполняться в своем контексте, независимо от функции goroutine().
То есть фактически goroutine() и fac() выполняются параллельно. Однако главной горутиной
является вызов функции goroutine(). И если завершается выполнение этой функции, то завершается
и выполнение всей программы. Поскольку вызовы функции fac представляют горутины, то функция goroutine()
не ждет их завершения и после их запуска продолжает свое выполнение. Какие-то горутины могут
завершиться раньше функции goroutine(), и соответственно мы сможем увидеть на консоли их результат.
Но может сложиться ситуация, что функция goroutine() выполнится раньше вызовов функции fac().
Поэтому мы можем не увидеть на консоли факториалы чисел.

Чтобы все таки увидеть результат выполнения горутин, поставим в конце функции goroutine()
вызов функции fmt.Scanln(), которая ожидает ввода пользователя с консоли:
*/
func goroutineInput() {
	fmt.Println("Функция горутин с ожиданием ввода пользователя")
	for i := 1; i < 7; i++ {
		go fac(i)
	}
	fmt.Scanln() // ждем ввода пользователя
	fmt.Println("The End")
}

/*
Теперь мы сможем увидеть результаты всех вызовов функции factorial:
1 - 1
3 - 6
5 - 120
4 - 24
2 - 2
6 - 720

The End

Стоит отметить, что так как каждая горутина запускается в своем собственном контексте и выполняется
независимо и паралелльно по сравнению с другими горутинами, то в данном случае нельзя четко
детерминировать, какая из горутин завершится раньше. Например, горутина go fac(2) запускается
до go fac(5), однако может завершиться после.

Горутины также могут представлять вызовы анонимных функций:
package main
import "fmt"

func main() {

    for i := 1; i < 7; i++{

        go func(n int){
            result := 1
            for j := 1; j <= n; j++{
                result *= j
            }
            fmt.Println(n, "-", result)
        }(i)
    }
    fmt.Scanln()
    fmt.Println("The End")
}*/
