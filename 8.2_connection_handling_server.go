package main

/*
Сервер. Обработка подключений

Для прослушивания и приемы входящих запросов в пакете net определена функция net.Listen:
func Listen(network, laddr string) (net.Listener, error)

Функция принимает два параметра: network - протокол, по которому приложение будет получать запросы,
и laddr представляет локальный адрес, по которому будет запускаться сервер. Протокол должен
представлять одно из значений: "tcp", "tcp4", "tcp6", "unix", "unixpacket".
Локальный адрес может содержать только номер порта, например, ":8080".
В этом случае приложение будет обслуживать по всем.

В случае успешного выполнения функция возвращает объект интерфейса net.Listener,
который представляет функционал для приема входящих подключений. В зависимости от типа используемого
протокола возвращаемый объект Listener может представлять тип net.TCPListener или net.UnixListener
(оба этих типа реализуют интерфейс net.Listener).

Основные методы, которые представляет net.Listener: Accept() (принимает входящее подключение)
и Close() (закрывает подключение).

package main
import (
    "fmt"
    "net"
)
func main() {
    message := "Hello, I am a server"   // отправляемое сообщение
    listener, err := net.Listen("tcp", ":4545")

    if err != nil {
        fmt.Println(err)
        return
    }
    defer listener.Close()
    fmt.Println("Server is listening...")
    for {
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println(err)
            return
        }
        conn.Write([]byte(message))
        conn.Close()
    }
}
Вначале в функции net.Listen("tcp", ":4545") устанавливается 4545 порт для прослушивания подключений
по протоколу TCP. После вызова этой функции сервер запущен и готов принимать подключения.
Затем в бесконечном цикле for получаем входящие подключения с помощью вызова listener.Accept().
Этот метод возвращает объект net.Conn, который представляет подключенного клиента.
Затем мы можем каким-нибудь образом обработать это подключение.
Например, с помощью метода Write отправить ему сообщение. Поскольку данный метод принимает срез байтов,
то любые сообщения надо транслировать в срез байтов: conn.Write([]byte(message))
*/

/*
Для тестирования сервера определим еще одну программу - клиент:
package main
import (
    "fmt"
    "os"
    "net"
    "io"
)
func main() {

    conn, err := net.Dial("tcp", "127.0.0.1:4545")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer conn.Close()

    io.Copy(os.Stdout, conn)
    fmt.Println("\nDone")
}
Поскольку сервер будет запущен на локальном компьтере на порте 4545, то клиент подлючается
к этому адресу: net.Dial("tcp", "127.0.0.1:4545")

После этого к серверу будет отправляться запрос, и с помощью вызова io.Copy(os.Stdout, conn)
выводим полученный ответ на консоль.

Вначале запустим сервер. На Windows может отобразиться окно с предложением разрешить доступ:

И после этого будет запущен сервер:

Затем запустим клиент:

После запуска клиент подключится к серверу и получит от него сообщение.
*/
