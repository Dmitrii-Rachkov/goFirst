package main

import "fmt"

/*
Срезы (slice) представляют последовательность элементов одного типа переменной длины.
В отличие от массивов длина в срезах не фиксирована и динамически может меняться, то есть можно
добавлять новые элементы или удалять уже существующие.

Срез определяется также, как и массив, за тем исключением, что у него не указывается длина:
*/
func oneSlice() {
	fmt.Println("Работа среза")
	var users []string = []string{"Tom", "Alice", "Kate"}
	fmt.Println(users[2])
	users[2] = "Katherine"
	fmt.Println(users[2])
	// К элементам среза обращение происходит также, как и к элементам массива - по индексу
	//и также мы можем перебирать все элементы с помощью цикла for:
	for _, value := range users {
		fmt.Println(value)

	}
}

/*
С помощью функции make() можно создать срез из нескольких элементов,
которые будут иметь значения по умолчанию:
*/
func makeSlice() {
	fmt.Println("Функция make в срезах")
	var users []int = make([]int, 3)
	for index, value := range users {
		fmt.Println(index, value)
	}
}

/*
Добавление в срез
Для добавления в срез применяется встроенная функция append(slice, value).
Первый параметр функции - срез, в который надо добавить, а второй параметр - значение, которое
нужно добавить. Результатом функции является увеличенный срез.
*/
func addSlice() {
	fmt.Println("Добавление в срез")
	users := []string{"Tom", "Alice", "Kate"}
	users = append(users, "Bob")
	for _, value := range users {
		fmt.Println(value)
	}
}

/*
Оператор среза

Оператор среза s[i:j] создает из последовательности s новый срез, который содержит элементы
последовательности s с i по j-1. При этом должно соблюдаться условие 0 <= i <= j <= cap(s).
В качестве исходной последовательности, из которой берутся элементы, может использоваться массив,
указатель на массив или другой срез. В итоге в полученном срезе будет j-i элементов.

Если значение i не указано, то применяется по умолчанию значение 0.
Если значение j не указано, то вместо него используется длина исходной последовательности s.
*/
func operatorSlice() {
	fmt.Println("Использование оператора i:j для вывода определенных элементов среза")
	initialUsers := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}
	users1 := initialUsers[2:6] // с 3-го по 6-й
	users2 := initialUsers[:4]  // с 1-го по 4-й
	users3 := initialUsers[3:]  // с 4-го до конца

	fmt.Println(users1) // ["Kate", "Sam", "Tom", "Paul"]
	fmt.Println(users2) // ["Bob", "Alice", "Kate", "Sam"]
	fmt.Println(users3) // ["Sam", "Tom", "Paul", "Mike", "Robert"]
}

/*
Удаление элемента

Что делать, если необходимо удалить какой-то определенный элемент?
В этом случае мы можем комбинировать функцию append и оператор среза:
*/
func deleteSlice() {
	fmt.Println("Удаляем четвертый элемент среза")
	users := []string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}
	//удаляем 4-й элемент
	var n = 3
	users = append(users[:n], users[n+1:]...)
	fmt.Println(users) //["Bob", "Alice", "Kate", "Tom", "Paul", "Mike", "Robert"]
}

/*
Так как слайс имеет нефиксированную длину, "под капотом" лежит более сложная структура, чем у массива.
Помимо самих значений слайс хранит 2 дополнительных свойства: длину массива len (длина)
и cap (вместимость). Благодаря этому возможно инициализировать слайс нужной длины с помощью встроенной
функции func make(t Type, len, cap IntegerType) Type. Понимание, где лучше использовать какой
способ инициализации, приходит с опытом, но для старта рекомендуется использовать make везде, где можно:

// len = 5. Массив сразу будет заполнен 5-ю нулевыми значениями
nums := make([]int, 5, 5) // [0, 0, 0, 0, 0]

// len = 0, но cap = 5. Массив будет пустым, однако заполнение слайса через append будет эффективным,
потому что в памяти уже выделен массив нужной длины
nums := make([]int, 0, 5) // []
*/
