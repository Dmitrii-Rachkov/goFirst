package main

import "fmt"

/*
Функция представляет блок операторов, которые все вместе выполняют какую-то определенную задачу. С помощью функций можно многократно вызывать ее блок операторов как единое целое в других частях программы.

Функция объявляется следующим образом:
func имя_функции (список_параметров) (типы_возвращаемых_значений){
    выполняемые_операторы
}

Функция определяется с помощью ключевого слова func, после которого идет имя функции.
Затем в скобках идет список параметров. После списка параметров определяются типы возвращаемых
из функции значений (если функция возвращает значения). И далее в фигурных скобках идут собственно
те операторы, из которых состоит функция.

Название функции вместе с типами ее параметров и типами возвращаемых значений еще называют сигнатурой.

По умолчанию каждая программа на языке Go должна содержать как минимум одну функцию - функцию main,
которая является входной точкой в приложение:
func main() {
    fmt.Println("Hello Go")
}

Функция main начинается с ключевого слова func, затем идет название - main.
Функция не принимает никаких параметров, поэтому после названия идут пустые скобки.
Функция main не возвращает никакого результата, поэтому после пустых скобок не указывается
тип возвращаемого значения. И тело функции в фигурных скобках фактически состоит из вызова
другой функции - fmt.Println(), которая выводит строку на консоль.

Теперь определим еще одну функцию:
package main
import "fmt"

func main() {

}

func hello(){
    fmt.Println("Hello World")
}

В данном случае мы определили функцию hello, которая не принимает никаких параметров, ничего не
возвращает и просто выводит на консоль строку. Определить функцию можно в том же файле, где расположена
функция main. Но если мы запустим эту программу, но на консоли мы ничего не увидим.
Потому что программа выполняет только те действия, которые определены внутри функции main.
Имя она является входной точкой в приложение. И если мы хотим выполнить в программе нашу функцию hello,
то нам надо вызвать ее в функции main:
package main
import "fmt"

func main() {
    hello()
    hello()
    hello()
}

func hello(){
    fmt.Println("Hello World")
}
Для вызова функции пишется ее имя, после которого в скобках указываются значения для параметров функции.
Но поскольку в данном случае функция hello не имеет параметров, то после ее названия пишем просто
пустые скобки.
*/

/*
Параметры функции
Через параметры функция получает входные данные. Параметры указываются в скобках после имени функции.
Для каждого параметра указывается имя и тип (как для переменной).
Друг от друга параметров разделяются запятыми. При вызове функции необходимо передать значения для
всех ее параметров. Например, мы хотим использовать функцию, которая складывает два любых числа:
*/
func add(x int, y int) {
	fmt.Println("Функция с параметрами")
	var z = x + y
	fmt.Println("x + y =", z)
}

/*
Если несколько параметров подряд имеют один и тот же тип, то мы можем указать тип только для последнего
параметра, а предыдущие параметры также будут представлять этот тип:
*/
func addType(x, y int, a, b, c float64) {
	fmt.Println("Указываем один раз тип всех аргументов")
	var z = x + y
	var d = a + b + c
	fmt.Println("x + y = ", z)
	fmt.Println("a + b + c = ", d)
}

/*
В качестве аргументов при вызове функции можно передавать и значения переменных, результаты операций
или других функций, но при этом следует учитывать, что аргументы в функцию всегда передаются по значению:
package main
import "fmt"

func main() {
    var a = 8
    fmt.Println("a before: ", a)
    increment(a)
    fmt.Println("a after: ", a)
}
func increment(x int){

    fmt.Println("x before: ", x)
    x = x + 20
    fmt.Println("x after: ", x)
}

В данном случае в качестве аргумента в функцию increment передается значение переменной a.
Параметр x получает это значение, и оно увеличивается на 20. Однако несмотря на то, что значение
параметра x увеличилось, значение переменной a никак не изменилось. Потому что при вызове функции
передается копия значения переменной.
*/

/*
Неопределенное количество параметров
В Go функция может принимать неопределенное количество параметров одного типа.
Например, нам надо получить сумму чисел, но мы точно не значем, сколько чисел будут переданы в функцию:
*/
func addMany(numbers ...int) {
	fmt.Println("Функция получает на вход неизвестное количество аргументов")
	var sum = 0
	for _, number := range numbers {
		sum += number
	}
	fmt.Println("sum = ", sum)
}

/*
Для определения параметра, который представляет неопределенное количество значений,
перед типом этих значений ставится многоточие: numbers ...int. То есть через подобный параметр
мы получаем несколько значений типа int.
*/

/*
От этого случае следует отличать передачу среза в качестве параметра:
add([]int{1, 2, 3})
add([]int{1, 2, 3, 4})
add([]int{5, 6, 7, 2, 3})
Такое мы не можем передавать, будет ошибка

Если мы хотим передать срез, то надо указать после аргумента-массива многоточие:
add([]int{1, 2, 3}...)
add([]int{1, 2, 3, 4}...)
var nums = []int{5, 6, 7, 2, 3}
add(nums...)
*/
