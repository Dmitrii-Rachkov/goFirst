package main

/*
По сравнению с операторами ветвления и циклами, оператор goto более гибок.
Он позволяет выполнять безусловные переходы внутри одной и той же функции.
Хотя чрезмерное использование goto может снизить читаемость кода, его основное преимущество заключается в гибкости.
При правильном использовании он не только повышает эффективность программы, но и делает код более лаконичным
и элегантным в определенных сценариях.

В этом лабораторном занятии (Lab) вы узнаете основы использования оператора goto в Go, а также его применение
в различных сценариях, таких как замена операторов break, реализация циклов и выход из вложенных циклов.
*/

/*синтаксис выглядит следующим образом

// Syntax 1: Jumping forward
goto label
...
label: code block

// Syntax 2: Jumping backward
label: code block
goto label

*/

/*
В Go оператор goto обладает гибкостью, так как позволяет делать переходы как вперед, так и назад в коде.
Метка (label) представляет собой маркер, который указывает, куда должен перейти поток управления программы.
Метки чувствительны к регистру, и для улучшения читаемости рекомендуется использовать заглавные буквы для меток.

Примечание: Объявление и использование меток должны происходить внутри одной и той же функции.
*/

/*
Пример:

Рассмотрим простую программу, демонстрирующую использование оператора goto.
В этом примере программа пропускает определенные строки и сразу переходит к метке:

package main

import "fmt"

func main() {
    fmt.Println(1)  // Prints the number 1
    goto NEXT        // Jumps to the label "NEXT"
    fmt.Println(2)  // This line is skipped
NEXT:
    fmt.Println(3)  // Prints the number 3
}

Программа начинается с вывода числа 1.
Затем она встречает оператор goto NEXT, который вызывает немедленный переход к метке NEXT.
В результате строка fmt.Println(2) пропускается, и программа продолжает выполнение с метки NEXT, выводя число 3.
*/

/*
Замена break на goto
В определенных ситуациях оператор goto может быть использован в качестве замены оператору break в циклах,
обеспечивая гибкость при выходе из циклов в зависимости от определенных условий.

package main

import "fmt"

func main() {
    for i := 0; ; i++ {         // An infinite loop
        if i == 10 {            // Condition to exit the loop
            goto END            // Jump to the "END" label
        }
        fmt.Print(i)            // Print the current value of i
    }
END:
    fmt.Println("END")          // Print "END" after exiting the loop
}

Программа запускает бесконечный цикл с помощью for i := 0; ; i++.
Внутри цикла проверяется, равно ли i значению 10.
Если условие выполняется, происходит переход к метке END, что приводит к выходу из цикла.
Перед переходом выводятся значения i от 0 до 9.
После выхода из цикла программа выводит END.
*/

/*
Реализация цикла for с использованием goto
Оператор goto также может быть использован для ручной реализации цикла. Хотя в Go есть встроенные циклы for,
данное упражнение демонстрирует, как goto может имитировать поведение цикла.

package main

import "fmt"

func main() {
    var i = 0            // Initialize a variable i
BEGIN:
    fmt.Printf("%d ", i) // Print the current value of i
    if i == 9 {          // Check if i has reached 9
        goto END         // Exit the loop if true
    }
    i++                  // Increment i
    goto BEGIN           // Jump back to the label "BEGIN"
END:
}

Программа инициализирует переменную i значением 0 и запускает цикл с использованием метки BEGIN.
Она выводит значение i и проверяет, достигло ли оно 9.
Если нет, то увеличивает i и делает переход обратно к метке BEGIN, повторяя процесс.
Как только i становится равным 9, программа переходит к метке END, завершая цикл.
*/

/*
Выход из вложенных циклов с использованием goto
Выход из вложенных циклов с помощью оператора break может быть громоздким, так как обычно требует
дополнительной логики и переменных.
Оператор goto упрощает этот процесс, позволяя делать прямые переходы из нескольких циклов.

package main

import "fmt"

func main() {
    for i := 0; i < 5; i++ {      // Outer loop
        for j := 0; j < 5; j++ {  // Inner loop
            if j == 3 {           // Exit condition
                goto END          // Jump to the "END" label
            }
            fmt.Println(i, j)     // Print the current values of i and j
        }
    }
END:
}

Программа начинается с вложенного цикла: внешний цикл для переменной i и внутренний цикл для переменной j.
Внутри внутреннего цикла проверяется, равно ли j значению 3.
Если условие выполняется, программа переходит к метке END, выходя из обоих циклов.
В результате программа выводит пары значений (i, j) только до тех пор, пока j не станет равным 2.
*/
