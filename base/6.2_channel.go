package main

import "fmt"

/*
Каналы

Каналы (channels) представляют инструменты коммуникации между горутинами.
Для определения канала применяется ключевое слово chan:
chan тип_элемента

После слова chan указывается тип данных, которые будут передаться с помощью канала. Например:
*/
var intCh chan int

/* Здесь переменная intCh представляет канал, который передает данные типа int.
Для передачи данных в канал или, наоборот, из канала применяется операция <- (направленная влево стрелка).
Например, передача данных в канал:
intCh <- 5
В данном случае в канал посылается число 5

Получение данных из канала в переменную:
val := <- intCh

Если ранее в канал было отправлено число 5, то при выполнении операции <- intCh мы можем получить
это число в переменную val.

Стоит учитывать, что мы можем отправить в канал и получить из канала данные только того типа,
который представляет канал. Так, в примере с каналом intCh это данные типа int.

Как правило, отправителем данных является одна горутина, а получателем - другая горутина.

При простом определении переменной канала она имеет значение nil, то есть по сути канал неинициализирован.
Для инициализации применяется функция make(). В зависимости от определения емкости канала
он может быть буферизированным или небуферизированным.
*/

/*
Небуфферизированные каналы

Для создания небуферизированного канала вызывается функция make() без указания емкости канала:
*/
var intChannel chan int = make(chan int) // канал для данных типа int
// strChannel := make(chan string) // канал для данных типа string

/*
Если канал пустой, то горутина-получатель блокируется, пока в канале не окажутся данные.
Когда горутина-отправитель посылает данные, горутина-получатель получает эти данные
и возобновляет работу.

Горутина-отправитель может отправлять данные только в пустой канал.
Горутина-отправитель блокируется до тех пор, пока данные из канала не будут получены. Например:
*/
func blockGoroutine() {
	fmt.Println("Блокировка горутины")
	intChan := make(chan int)

	go func() {
		fmt.Println("Go routine starts")
		intChan <- 5 // блокировка, пока данные не будут получены функцией blockGoroutine
	}()
	fmt.Println(<-intChan) // получение данных из канала
	fmt.Println("The End")
}

/*
Через небуферизированный канал intChan горутина, представленная анонимной функцией, передает число 5:
intCh <- 5

А функция blockGoroutine() получает это число:
fmt.Println(<-intCh)

Общий ход выполнения программы выглядит следующим образом:

Запускается функция blockGoroutine(). Она создает канал intChan и запускает горутину
в виде анонимной функции.

Функция blockGoroutine() продолжает выполняться и блокируется на строке fmt.Println(<-intCh),
пока не будут получены данные.

Параллельно выполняется запущенная горутина в виде анонимной функции. В конце своего выполнения она
отправляет даные через канал: intChan <- 5. Горутина блокируется, пока функция blockGoroutine()
не получит данные.

Функция blockGoroutine() получает отправленные данные, деблокируется и продолжает свою работу.

В данном случае горутина определена в виде анонимной функции и поэтому она имеет доступ к окружению,
в том числе к переменной intCh.
*/

/*
Если же мы работаем с обычными функциями, то объекты каналов надо передавать через параметры:
package main
import "fmt"

func main() {

    intCh := make(chan int)

    go factorial(5, intCh)  // вызов горутины
    fmt.Println(<-intCh) // получение данных из канала
    fmt.Println("The End")
}

func factorial(n int, ch chan int){

    result := 1
    for i := 1; i <= n; i++{
        result *= i
    }
    fmt.Println(n, "-", result)

    ch <- result     // отправка данных в канал
}
Обратите внимание, как определяется параметр, который представляет канал данных типа int: ch chan int.
Консольный вывод данной программы:
5 - 120
120
The End

Таким образом, при использовании канала вызывающий поток - функция main ожидает завершения
выполнения горутины.

Стоит отметить, что отправителем данных должна быть отдельно запускаемая горутина.
Например, если мы определим отправление и получение данных через канал в самой функции main,
то мы столкнемся с взаимоблокировкой:
package main
import "fmt"

func main() {

    intCh := make(chan int)
    intCh <- 10      // функция main блокируется
    fmt.Println(<-intCh)
}
*/

/*
Буферизированные каналы

Буферизированные каналы также создаются с помощью функции make(), только в качестве второго аргумента
в функцию передается емкость канала. Если канал пуст, то получатель ждет, пока в канале
появится хотя бы один элемент.

При отправке данных горутина-отправитель ожидает, пока в канале не освободится место для еще одного
элемента и отправляет элемент, только тогда, когда в канале освобождается для него место.
Пример:
*/
func buferChannel() {
	fmt.Println("Буферизированные каналы")
	intCh := make(chan int, 3)
	intCh <- 10
	intCh <- 3
	intCh <- 24
	fmt.Println(<-intCh) // 10
	fmt.Println(<-intCh) // 3
	fmt.Println(<-intCh) //24
}

/*
В данном случае отправителем и получателем данных является функция buferChannel().
В ней создается канал из трех элементов, и последовательно отправляются три значения типа int.

В то же время в данном случае должно быть соответствие между количеством отправляемых и получаемых данных.
Если в функции buferChannel() будет одновременно отправлено значений больще, чем вмещает канал,
то функция заблокируется:

func buferChannel() {
	fmt.Println("Буферизированные каналы")
	intCh := make(chan int, 3)
	intCh <- 10
	intCh <- 3
	intCh <- 24
	intCh <- 15  // блокировка - функция buferChannel() ждет, когда освободится место в канале
	fmt.Println(<-intCh)
	fmt.Println("The End")
}
*/

/*
С помощью встроенных функций cap() и len() можно получить соответственно емкость и
количество элементов в канале:
*/
func capLen() {
	fmt.Println("Емкость и количество элементов в канале")
	intCh := make(chan int, 3)
	intCh <- 10

	fmt.Println(cap(intCh)) // 3
	fmt.Println(len(intCh)) // 1

	fmt.Println(<-intCh)
}

/*
Однонаправленные каналы

В Go можно определить канал, как доступный только для отправки данных или только для получения данных.
Определение канала только для отправки данных:
var inCh chan<- int
Определение канала только для получения данных:
var outCh <-chan int

Например:
package main
import "fmt"

func main() {

    intCh := make(chan int, 2)
    go factorial(5, intCh)
    fmt.Println(<-intCh)
    fmt.Println("The End")
}

func factorial(n int, ch chan<- int){

    result := 1
    for i := 1; i <= n; i++{
        result *= i
    }
    ch <- result
}
Здесь второй параметр функции factorial определен как канал, доступный только для отправки данных:
ch chan<- int. Соответственно внутри функции factorial мы можем только отправлять данные в канал,
но не получать их.
*/

/*
Возвращение канала

Канал может быть возвращаемым значением функции.
Однако следует внимательно подходить к операциям записи и чтения в возвращаемом канале.
Например:
package main
import "fmt"

func main() {
    fmt.Println("Start")
     // создание канала и получение из него данных
    fmt.Println(<-createChan(5)) // блокировка
    fmt.Println("End")
}
func createChan(n int) chan int{
    ch := make(chan int)    // создаем канал
    ch <- n      // отправляем данные в канал
    return ch   // возвращаем канал
}
Функция createChan возвращает канал. Однако при выполнении операции ch <- n мы столкнемся с блокировкой,
поскольку происходит ожидание получения данных из канала. Поэтому следующее выражение return ch
не будет выполняться.
*/

/*
И если все таки необходимо определить функцию, которая возвращает канал, то все операции
чтения-записи в канал следует вынести в отдельную горутину:
package main
import "fmt"

func main() {
    fmt.Println("Start")
     // создание канала и получение из него данных
    fmt.Println(<-createChan(5)) // 5
    fmt.Println("End")
}
func createChan(n int) chan int{
    ch := make(chan int)    // создаем канал
    go func(){
        ch <- n      // отправляем данные в канал
    }()             // запускаем горутину
    return ch   // возвращаем канал
}
*/

/*
На стороне писателя мы закрываем канал, а на стороне читателя проверям открыт ли канал,
чтобы не возникало panic.
*/

/*
Взаимная блокировка канала

Deadlock (Взаимная блокировка)

Как уже ранее говорилось, чтение или запись данных в канал блокирует горутину и контроль передается
свободной горутине. Представим, что такие горутины отсутствуют, либо они все "спят".
В этот момент возникает deadlock, который приведет к аварийному завершению программы.

Если вы попытаетесь считать данные из канала, но в канале будут отсутствовать данные, планировщик
заблокирует текущую горутину и разблокирует другую в надежде, что какая-либо горутина передаст данные
в канал. То же самое произойдет в случае отправки данных: планировщик заблокирует передающую горутину,
пока другая не считает данные из канала.
Примером deadlock может быть main горутина, которая эксклюзивно производит операции с каналом.

package main

import "fmt"

func main() {
    fmt.Println("main() started")

    c := make(chan string)
    c <- "John"

    fmt.Println("main() stopped")
}

Программа выше выведет следующее при попытке ее исполнить:

main() started
fatal error: all goroutines are asleep - deadlock!
goroutine 1 [chan send]:
main.main()
        program.go:10 +0xfd
exit status 2
*/

/*
Закрытие канала

В Go так же можно закрыть канал, через закрытый канал невозможно будет передать или принять данные.
Горутина может проверить закрыт канал или нет, используя следующую конструкцию: val, ok := <- channel,
где ok будет истиной в случае, если канал открыт или операция чтения может быть выполнена,
иначе ok будет false, если канал закрыт и отсутствуют данных для чтения из него.
Закрыть канал можно, используя встроенную функцию close, используя следующий синтаксис close(channel).
Давайте рассмотрим следующий пример:

package main

import "fmt"

func greet(c chan string) {
    <-c // for John
    <-c // for Mike
}

func main() {
    fmt.Println("main() started")

    c := make(chan string, 1)

    go greet(c)
    c <- "John"

    close(c) // closing channel

    c <- "Mike"
    fmt.Println("main() stopped")
}

Для понимания концепта блокировки первая операция отправки c <- "John" будет блокирующей, и другая
горутина должна будет считать данные из канала, следовательно greet горутина будет запланирована
планировщиком. Затем первая операция чтения будет неблокируемой, поскольку присутствуют данные для
чтения в канале c. Вторая операция чтения будет блокируемой, потому что в канале c отсутствуют данные,
поэтому планировщик переключится на main горутину и программа выполнит закрытие канала close(c).

Вывод программы:

main() started
panic: send on closed channel

goroutine 1 [running]:
main.main()
    program.go:20 +0x120
exit status 2

Как вы можете заметить, программа завершилась с ошибкой, которая говорит, что запись в закрытый
канал невозможна. Для дальнейшего понимания закрытия каналов давайте рассмотрим пример с циклом for.
*/

/*
Пример с циклом for

package main

import "fmt"

func squares(c chan int) {
    for i := 0; i <= 9; i++ {
        c <- i * i
    }

    close(c) // close channel
}

func main() {
    fmt.Println("main() started")
    c := make(chan int)

    go squares(c) // start goroutine

    // periodic block/unblock of main goroutine until chanel closes
    for {
        val, ok := <-c
        if ok == false {
            fmt.Println(val, ok, "<-- loop broke!")
            break // exit break loop
        } else {
            fmt.Println(val, ok)
        }
    }

    fmt.Println("main() stopped")
}

Бесконечный цикл может быть полезен для чтения данных из канала, когда мы не знаем сколько данных
мы ожидаем. В этом примере мы создаем горутину squares, которая последовательно возвращает квадраты
чисел от 0 до 9. В main мы считываем эти числа внутри цикла for.

В цикле мы считываем данные из канала, используя ранее рассмотренный синтаксис val, ok := <-c,
где ok предоставляет нам информацию о том, что канал закрыт. В горутине squares после того, как
записали все данные, мы закрываем канал, используя функцию close. Когда ok будет true, программа
выведет значение val и статус канала (переменная ok). Когда ok станет false, мы завершим цикл,
используя ключевое слово break. Таким образом мы получим следующий результат:

main() started
0 true
1 true
4 true
9 true
16 true
25 true
36 true
49 true
64 true
81 true
0 false <-- loop broke!
main() stopped

Когда канал закрыт, значение val, считанное горутиной, является нулевым значением, в зависимости
от типа данных канала. Так как в нашем случае тип данных канала int, то нулевое значение будет 0,
как раз это мы и видим в этой строке: 0 false <-- loop broke!


Для того, чтобы избежать столь громоздкой проверки закрытия канала в случае цикла for,
Go предоставляет ключевое слово range, которое автоматически останавливает цикл, когда
канал будет закрыт. Давайте перепишем нашу программу с использованием range:

package main

import "fmt"

func squares(c chan int) {
    for i := 0; i <= 9; i++ {
        c <- i * i
    }

    close(c) // close channel
}

func main() {
    fmt.Println("main() started")
    c := make(chan int)

    go squares(c) // start goroutine

    // periodic block/unblock of main goroutine until chanel closes
    for val := range c {
        fmt.Println(val)
    }

    fmt.Println("main() stopped")
}

В этом примере мы использовали val := range c вместо бесконечного цикла, где range будет считывать
данные из канала до тех пор, пока канал не будет закрыт. В результате программа выведет следующее:

main() started
0
1
4
9
16
25
36
49
64
81
main() stopped

Если вы не закроете канал для цикла for с использованием range, то программа будет завершена
аварийно из-за dealock во время выполнения.
*/

/*
select

select похож на switch без аргументов, но он может использоваться только для операций с каналами.
Оператор select используется для выполнения операции только с одним из множества каналов, условно
выбранного блоком case.
Давай взглянем на пример ниже, и обсудим как он работает:

package main

import (
    "fmt"
    "time"
)

var start time.Time
func init() {
    start = time.Now()
}

func service1(c chan string) {
    time.Sleep(3 * time.Second)
    c <- "Hello from service 1"
}

func service2(c chan string) {
    time.Sleep(5 * time.Second)
    c <- "Hello from service 2"
}

func main() {
    fmt.Println("main() started", time.Since(start))

    chan1 := make(chan string)
    chan2 := make(chan string)

    go service1(chan1)
    go service2(chan2)

    select {
    case res := <-chan1:
        fmt.Println("Response from service 1", res, time.Since(start))
    case res := <-chan2:
        fmt.Println("Response from service 2", res, time.Since(start))
    }

    fmt.Println("main() stopped", time.Since(start))
}

В этом примере мы используем оператор select как switch, но вместо булевых операций, мы используем
операции для чтения данных из канала. Оператор select также является блокируемым, за исключением
использования default(позже вы увидите пример с его использованием). После выполнения одного из
блоков case, горутина main будет разблокирована. Задались вопросом когда case условие выполнится?

Если все блоки case являются блокируемыми, тогда select будет ждать до момента, пока один из блоков
case разблокируется и будет выполнен. Если несколько или все канальные операции не блокируемы,
тогда один из неблокируемых case будет выбран случайным образом (Примечание переводчика:
имеется ввиду случай, когда пришли одновременно данные из двух и более каналов).

Давайте наконец разберем программу, которую написали ранее. Мы запустили 2 горутины с независимыми
каналами. Затем мы использовали оператор select c двумя case операторами. Один case считывает данные
из chan1 а другой из chan2. Так как каналы не используют буфер, операция чтения будет блокируемой.
Таким образом оба case будут блокируемыми и select будет ждать до тех пор, пока один из case не
разблокируется.

Когда программа находится в блоке select горутина main будет заблокирована и будут запланированы все
горутины (по одной за раз), которые используются в блоке select, в нашем случае это service1 и service2
. service1 ждет 3 секунды, после чего будет разблокирован и сможет записать данные в chan1.
Таким же образом как и service1 действует service2, только он ожидает 5 секунд и осуществляет запись
в chan2. Так как service1 разблокируется раньше, чем service2, первый case разблокируется раньше и
произведет чтение из chan1, а второй case будет проигнорирован. После чего управление вернется в main,
и программа завершится после вывода в консоль.

Вывод программы:

main() started 0s
Response from service 1 Hello from service 1 3s
main() stopped 3s

Вышеприведенная программа имитирует реальный веб-сервис, в котором балансировщик нагрузки получает
миллионы запросов и должен возвращать ответ от одной из доступных служб. Используя стандартные
горутины, каналы и select, мы можем запросить ответ у нескольких сервисов, и тот, который ответит
раньше всех, может быть использован.

Для того, чтобы симулировать случай, когда все блоки case разблокируются в одно и тоже время,
мы может просто удалить вызов Sleep из горутин.

package main

import (
    "fmt"
    "time"
)

var start time.Time
func init() {
    start = time.Now()
}

func service1(c chan string) {
    c <- "Hello from service 1"
}

func service2(c chan string) {
    c <- "Hello from service 2"
}

func main() {
    fmt.Println("main() started", time.Since(start))

    chan1 := make(chan string)
    chan2 := make(chan string)

    go service1(chan1)
    go service2(chan2)

    select {
    case res := <-chan1:
        fmt.Println("Response from service 1", res, time.Since(start))
    case res := <-chan2:
        fmt.Println("Response from service 2", res, time.Since(start))
    }

    fmt.Println("main() stopped", time.Since(start))
}

Данная программа выводит следующий результат:

main() started 0s
service2() started 481µs
Response from service 2 Hello from service 2 981.1µs
main() stopped 981.1µs

Но иногда вы можете получить следующий результат:

main() started 0s
service1() started 484.8µs
Response from service 1 Hello from service 1 984µs
main() stopped 984µs

Это происходит потому, что операции chan1 и chan2 выполняются практически одновременно,
но все же существует некоторая разница во времени при исполнении и планировании горутин.

Для того, чтобы сделать все блоки case неблокируемыми, мы можем использовать каналы с буфером.

package main

import (
    "fmt"
    "time"
)

var start time.Time

func init() {
    start = time.Now()
}

func main() {
    fmt.Println("main() started", time.Since(start))
    chan1 := make(chan string, 2)
    chan2 := make(chan string, 2)

    chan1 <- "Value 1"
    chan1 <- "Value 2"
    chan2 <- "Value 1"
    chan2 <- "Value 2"

    select {
    case res := <-chan1:
        fmt.Println("Response from chan1", res, time.Since(start))
    case res := <-chan2:
        fmt.Println("Response from chan2", res, time.Since(start))
    }

    fmt.Println("main() stopped", time.Since(start))
}

Вывод может быть следующим:

main() started 0s
Response from chan2 Value 1 0s
main() stopped 1.0012ms

Или таким:

main() started 0s
Response from chan1 Value 1 0s
main() stopped 1.0012ms

В приведенной программе оба канала имеют буфер размером 2. Так как мы отправляем 2 значения в буфер,
горутина не будет заблокирована и программа перейдет в блок select. Чтение из буферизированного канала
не является блокируемой операцией, если буфер не пустой, поэтому все блоки case будут неблокируемыми,
и во время выполнения Go выберет case случайным образом.


*/
