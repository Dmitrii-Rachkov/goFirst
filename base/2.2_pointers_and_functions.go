package main

import "fmt"

/*
Указатели и функции

# Указатели как параметры функции

По умолчанию все параметры передаются в функцию по значению. Например:
*/
func changeValue(x int) {
	x = x * x
}

func startChange() {
	fmt.Println("Значение первоначальной переменной не изменилось после обработки методом")
	d := 5
	fmt.Println("d before: ", d) // 5
	changeValue(d)               // изменяем значение
	fmt.Println("d after: ", d)  // 5 - значение не изменилось
}

/*
Функция changeValue изменяет значение параметра, возводя его в квадрат.
Но после вызова этой функции мы видим, что значение переменной d, которая передается в changeValue,
не изменилось. Ведь функция получает копию данной переменной и работает с ней независимо
от оригинальной переменной d. Поэтому d никак не изменяется.

Однако что, если нам все таки надо менять значение передаваемой переменной?
И в этом случае мы можем использовать указатели:
*/
func changeVar(x *int) {
	*x = *x * *x
}

func newVar() {
	fmt.Println("Изменяем исходную переменноу указателем")
	d := 5
	fmt.Println("d before: ", d) // 5
	changeVar(&d)                // изменяем значение
	fmt.Println("d after: ", d)  // 25 - значение изменилось
}

/*
Теперь функция changeValue принимает в качестве параметра указатель на объект типа int.
При вызове функции changeValue в нее передается адрес переменной d (changeValue(&d)).
И после ее выполнения мы видим, что значение переменной d изменилось.
*/

/*
Указатель как результат функции
Функция может возвращать указатель:
*/
func createPointer(x int) *int {
	p := new(int)
	*p = x
	return p
}

func returnPointer() {
	fmt.Println("Функция возвращает указатель")
	p1 := createPointer(7)
	fmt.Println("p1:", *p1) // p1: 7
	p2 := createPointer(10)
	fmt.Println("p2:", *p2) // p2: 10
	p3 := createPointer(28)
	fmt.Println("p3:", *p3) // p3: 28
}
