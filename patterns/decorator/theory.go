package decorator

/*
Декоратор
Также известен как: Wrapper, Обёртка, Decorator

Суть паттерна
Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую
функциональность, оборачивая их в полезные «обёртки».
*/

/*
Проблема

Вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам,
чтобы получать уведомления о важных событиях.

Основой библиотеки является класс Notifier с методом send, который принимает на вход строку-сообщение
и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект,
указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.

image_1.png

В какой-то момент стало понятно, что одних email-оповещений пользователям мало.
Некоторые из них хотели бы получать извещения о критических проблемах через SMS.
Другие хотели бы получать их в виде сообщений Facebook.
Корпоративные пользователи хотели бы видеть сообщения в Slack.

Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса Notifier.
Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу?
Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли?

Вы попытались реализовать все возможные комбинации подклассов оповещений.
Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.

image_2.png

Итак, нужен какой-то другой способ комбинирования поведения объектов, который не приводит к взрыву количества подклассов.
*/

/*
Решение

Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее поведение.
Но механизм наследования имеет несколько досадных проблем.

Он статичен. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав
другой подкласс.
Он не разрешает наследовать поведение нескольких классов одновременно. Из-за этого вам приходится создавать множество
подклассов-комбинаций для получения совмещённого поведения.
Одним из способов обойти эти проблемы является замена наследования агрегацией либо композицией .
Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его
поведение. Как раз на этом принципе построен паттерн Декоратор.

Декоратор имеет альтернативное название — обёртка. Оно более точно описывает суть паттерна: вы помещаете целевой объект
в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым
или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое
поведение всех обёрток сразу.

В примере с оповещениями мы оставим в базовом классе простую отправку по электронной почте,
а расширенные способы отправки сделаем декораторами.

image_3.png

Сторонняя программа, выступающая клиентом, во время первичной настройки будет заворачивать объект оповещений в те
обёртки, которые соответствуют желаемому способу оповещения.

image_4.png

Последняя обёртка в списке и будет тем объектом, с которым клиент будет работать в остальное время.
Для остального клиентского кода, по сути, ничего не изменится, ведь все обёртки имеют точно такой же интерфейс,
что и базовый класс оповещений.

Таким же образом можно изменять не только способ доставки оповещений, но и форматирование, список адресатов и так далее.
К тому же клиент может «дообернуть» объект любыми другими обёртками, когда ему захочется.
*/

/*
 Аналогия из жизни

Любая одежда — это аналог Декоратора. Применяя Декоратор, вы не меняете первоначальный класс и не создаёте дочерних
классов. Так и с одеждой — надевая свитер, вы не перестаёте быть собой, но получаете новое свойство — защиту от холода.
Вы можете пойти дальше и надеть сверху ещё один декоратор — плащ, чтобы защититься и от дождя.
*/

/*
Структура

image_5.png
*/

/*
Применимость

1. Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.

- Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс,
поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

2. Когда нельзя расширить обязанности объекта с помощью наследования.

- Во многих языках программирования есть ключевое слово final, которое может заблокировать наследование класса.
Расширить такие классы можно только с помощью Декоратора.
*/

/*
Шаги реализации

1. Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.

2. Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений.

3. Создайте класс конкретного компонента и поместите в него основную бизнес-логику.

4. Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент.
Все методы базового декоратора должны делегировать действие вложенному объекту.

5. И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.

6. Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен
выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта.

7. Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.
*/

/*
Преимущества

- Большая гибкость, чем у наследования.
- Позволяет добавлять обязанности на лету.
- Можно добавлять несколько новых обязанностей сразу.
- Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.
*/

/*
Недостатки
- Трудно конфигурировать многократно обёрнутые объекты.
- Обилие крошечных классов.
*/

/*
 Отношения с другими паттернами

- Адаптер предоставляет совершенно другой интерфейс для доступа к существующему объекту. С другой стороны,
при использовании паттерна Декоратор интерфейс либо остается прежним, либо расширяется. Причём Декоратор поддерживает
рекурсивную вложенность, чего не скажешь об Адаптере.

- С Адаптером вы получаете доступ к существующему объекту через другой интерфейс. Используя Заместитель,
интерфейс остается неизменным. Используя Декоратор, вы получаете доступ к объекту через расширенный интерфейс.

- Цепочка обязанностей и Декоратор имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного
выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.

Обработчики в Цепочке обязанностей могут выполнять произвольные действия, независимые друг от друга, а также в любой
момент прерывать дальнейшую передачу по цепочке. С другой стороны Декораторы расширяют какое-то определённое действие,
не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.

- Компоновщик и Декоратор имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности.
Она позволяет связать в одну структуру бесконечное количество объектов.

Декоратор оборачивает только один объект, а узел Компоновщика может иметь много детей. Декоратор добавляет вложенному
объекту новую функциональность, а Компоновщик не добавляет ничего нового, но «суммирует» результаты всех своих детей.

Но они могут и сотрудничать: Компоновщик может использовать Декоратор, чтобы переопределить функции отдельных частей
дерева компонентов.

- Архитектура, построенная на Компоновщиках и Декораторах, часто может быть улучшена за счёт внедрения Прототипа.
Он позволяет клонировать сложные структуры объектов, а не собирать их заново.

- Стратегия меняет поведение объекта «изнутри», а Декоратор изменяет его «снаружи».

- Декоратор и Заместитель имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены
на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что Заместитель сам управляет
жизнью сервисного объекта, а обёртывание Декораторов контролируется клиентом.
*/
